<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Destruction Zone - Matter.js Prototype</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000011;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #00ffff;
            padding: 20px;
        }

        h1 {
            margin-bottom: 15px;
            font-size: 24px;
            text-shadow: 0 0 10px #00ffff;
        }

        #gameContainer {
            display: flex;
            flex-direction: row;
            gap: 0;
            align-items: stretch;
        }

        #canvasWrapper {
            position: relative;
        }

        #pixiContainer {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        #pixiContainer canvas {
            display: block;
        }

        /* Ï¢åÏ∏° ÏÇ¨Ïù¥ÎìúÎ∞î - 3Í∞ú ÏÑ∏Î°ú Î∞∞Ïπò */
        #leftStats {
            display: flex;
            flex-direction: column;
            gap: 0;
            width: 60px;
        }

        /* Ïö∞Ï∏° ÏÇ¨Ïù¥ÎìúÎ∞î - 3Í∞ú ÏÑ∏Î°ú Î∞∞Ïπò */
        #rightStats {
            display: flex;
            flex-direction: column;
            gap: 0;
            width: 60px;
        }

        /* Í∞Å ÌÉ±ÌÅ¨ Ïä§ÌÉØ Ìå®ÎÑê - ÏÑ∏Î°úÎ°ú Í∏∏Í≤å */
        .tank-stat {
            background: rgba(0, 10, 15, 0.8);
            border: 1px solid #006666;
            border-top: none;
            padding: 8px 3px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            height: 240px; /* 720 / 3 = 240 */
            justify-content: flex-start;
        }

        .tank-stat:first-child {
            border-top: 1px solid #006666;
        }

        .tank-stat .tank-name {
            font-size: 11px;
            font-weight: normal;
            font-family: monospace;
            color: #00ffff;
        }

        .tank-stat .gauges {
            display: flex;
            gap: 6px;
            flex-direction: row;
            justify-content: center;
            flex: 1;
        }

        .gauge-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            flex: 1;
        }

        .gauge-label {
            font-size: 9px;
            font-family: monospace;
            color: #00cccc;
        }

        /* ÏÑ∏Î°ú Í≤åÏù¥ÏßÄ Î∞î */
        .gauge {
            width: 12px;
            height: 140px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #004444;
            position: relative;
            overflow: hidden;
        }

        /* ÏïÑÎûòÏóêÏÑú ÏúÑÎ°ú Ï∞®Ïò§Î•¥Îäî Í≤åÏù¥ÏßÄ */
        .gauge-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            transition: height 0.2s ease;
        }

        .gauge-fill.health {
            background: #00cc00;
        }

        .gauge-fill.weapon {
            background: #cccc00;
        }

        .tank-stat .weapon-info {
            font-size: 10px;
            font-family: monospace;
            color: #cccccc;
        }

        .tank-stat .score {
            font-size: 9px;
            font-family: monospace;
            color: #999999;
        }

        #gameCanvas {
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            background: #000011;
        }

        #debugInfo {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border: 1px solid #ff00ff;
            font-size: 11px;
            line-height: 1.5;
            color: #ff00ff;
        }
    </style>
</head>
<body>
    <h1>üéÆ DESTRUCTION ZONE</h1>

    <div id="gameContainer">
        <!-- Ï¢åÏ∏° ÏÇ¨Ïù¥ÎìúÎ∞î: Tank 1, 2, 3 -->
        <div id="leftStats">
            <div class="tank-stat" id="tank1-stat">
                <div class="tank-name">TANK 1</div>
                <div class="gauges">
                    <div class="gauge-container">
                        <div class="gauge-label">HP</div>
                        <div class="gauge">
                            <div class="gauge-fill health" style="height: 100%"></div>
                        </div>
                    </div>
                    <div class="gauge-container">
                        <div class="gauge-label">WPN</div>
                        <div class="gauge">
                            <div class="gauge-fill weapon" style="height: 100%"></div>
                        </div>
                    </div>
                </div>
                <div class="weapon-info">MISSILE</div>
                <div class="score">$0</div>
            </div>
            <div class="tank-stat" id="tank2-stat">
                <div class="tank-name">TANK 2</div>
                <div class="gauges">
                    <div class="gauge-container">
                        <div class="gauge-label">HP</div>
                        <div class="gauge">
                            <div class="gauge-fill health" style="height: 100%"></div>
                        </div>
                    </div>
                    <div class="gauge-container">
                        <div class="gauge-label">WPN</div>
                        <div class="gauge">
                            <div class="gauge-fill weapon" style="height: 100%"></div>
                        </div>
                    </div>
                </div>
                <div class="weapon-info">MISSILE</div>
                <div class="score">$0</div>
            </div>
            <div class="tank-stat" id="tank3-stat">
                <div class="tank-name">TANK 3</div>
                <div class="gauges">
                    <div class="gauge-container">
                        <div class="gauge-label">HP</div>
                        <div class="gauge">
                            <div class="gauge-fill health" style="height: 0%"></div>
                        </div>
                    </div>
                    <div class="gauge-container">
                        <div class="gauge-label">WPN</div>
                        <div class="gauge">
                            <div class="gauge-fill weapon" style="height: 0%"></div>
                        </div>
                    </div>
                </div>
                <div class="weapon-info">-</div>
                <div class="score">-</div>
            </div>
        </div>

        <!-- Í≤åÏûÑ Ï∫îÎ≤ÑÏä§ + PixiJS Ïò§Î≤ÑÎ†àÏù¥ -->
        <div id="canvasWrapper">
            <canvas id="gameCanvas" width="960" height="720"></canvas>
            <div id="pixiContainer"></div>
        </div>

        <!-- Ïö∞Ï∏° ÏÇ¨Ïù¥ÎìúÎ∞î: Tank 4, 5, 6 -->
        <div id="rightStats">
            <div class="tank-stat" id="tank4-stat">
                <div class="tank-name">TANK 4</div>
                <div class="gauges">
                    <div class="gauge-container">
                        <div class="gauge-label">HP</div>
                        <div class="gauge">
                            <div class="gauge-fill health" style="height: 0%"></div>
                        </div>
                    </div>
                    <div class="gauge-container">
                        <div class="gauge-label">WPN</div>
                        <div class="gauge">
                            <div class="gauge-fill weapon" style="height: 0%"></div>
                        </div>
                    </div>
                </div>
                <div class="weapon-info">-</div>
                <div class="score">-</div>
            </div>
            <div class="tank-stat" id="tank5-stat">
                <div class="tank-name">TANK 5</div>
                <div class="gauges">
                    <div class="gauge-container">
                        <div class="gauge-label">HP</div>
                        <div class="gauge">
                            <div class="gauge-fill health" style="height: 0%"></div>
                        </div>
                    </div>
                    <div class="gauge-container">
                        <div class="gauge-label">WPN</div>
                        <div class="gauge">
                            <div class="gauge-fill weapon" style="height: 0%"></div>
                        </div>
                    </div>
                </div>
                <div class="weapon-info">-</div>
                <div class="score">-</div>
            </div>
            <div class="tank-stat" id="tank6-stat">
                <div class="tank-name">TANK 6</div>
                <div class="gauges">
                    <div class="gauge-container">
                        <div class="gauge-label">HP</div>
                        <div class="gauge">
                            <div class="gauge-fill health" style="height: 0%"></div>
                        </div>
                    </div>
                    <div class="gauge-container">
                        <div class="gauge-label">WPN</div>
                        <div class="gauge">
                            <div class="gauge-fill weapon" style="height: 0%"></div>
                        </div>
                    </div>
                </div>
                <div class="weapon-info">-</div>
                <div class="score">-</div>
            </div>
        </div>
    </div>

    <div id="debugInfo" style="display: none;"></div>

    <!-- Matter.js Library -->
    <script src="js/lib/matter.min.js"></script>

    <!-- PixiJS Library (v7) -->
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.3.2/dist/pixi.min.js"></script>

    <!-- Prototype Script -->
    <script>
        // ============================================
        // Matter.js Prototype - Single Tank Test
        // ============================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Create Matter.js engine
        const Engine = Matter.Engine;
        const World = Matter.World;
        const Bodies = Matter.Bodies;
        const Body = Matter.Body;
        const Vector = Matter.Vector;

        const engine = Engine.create({
            gravity: { x: 0, y: 0 }  // Top-down, no gravity
        });

        const world = engine.world;

        // ============================================
        // PixiJS Setup (Particle Effects Layer)
        // ============================================
        let pixiApp;
        let particleContainer;
        const activeParticles = [];

        function initPixiJS() {
            pixiApp = new PIXI.Application({
                width: 960,
                height: 720,
                backgroundAlpha: 0,  // ÏôÑÏ†Ñ Ìà¨Î™Ö Î∞∞Í≤Ω (Ï§ëÏöî!)
                antialias: true
            });

            const container = document.getElementById('pixiContainer');
            if (container) {
                container.appendChild(pixiApp.view);
            }

            particleContainer = new PIXI.Container();
            pixiApp.stage.addChild(particleContainer);

            console.log('‚úÖ PixiJS initialized');
        }

        // PixiJS ÌååÌã∞ÌÅ¥ ÌÅ¥ÎûòÏä§ (ÎÑ§Ïù¥Ìã∞Î∏å Íµ¨ÌòÑ)
        class Particle extends PIXI.Graphics {
            constructor(x, y, vx, vy, config) {
                super();

                // ÏõêÌòï ÌååÌã∞ÌÅ¥ Í∑∏Î¶¨Í∏∞
                this.beginFill(config.startColor || 0xffff00);
                this.drawCircle(0, 0, config.radius || 3);
                this.endFill();

                this.position.set(x, y);
                this.vx = vx;
                this.vy = vy;

                this.maxLife = config.lifetime || 1.0;
                this.life = this.maxLife;
                this.startColor = config.startColor || 0xffff00;
                this.endColor = config.endColor || 0xff0000;
                this.damping = config.damping || 0.95;
            }

            update(deltaTime) {
                // ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;

                // ÏÜçÎèÑ Í∞êÏÜç
                this.vx *= this.damping;
                this.vy *= this.damping;

                // ÏÉùÎ™Ö Í∞êÏÜå
                this.life -= deltaTime;

                // Ìà¨Î™ÖÎèÑ
                this.alpha = this.life / this.maxLife;

                // ÏÉâÏÉÅ Î≥ÄÌôî (Í∞ÑÎã®ÌïòÍ≤å 50% Í∏∞Ï§Ä)
                const progress = 1 - (this.life / this.maxLife);
                this.tint = progress < 0.5 ? this.startColor : this.endColor;

                return this.life > 0;
            }
        }

        // ÌÉ±ÌÅ¨ Ìè≠Î∞ú ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
        function createTankExplosionParticles(x, y) {
            if (!particleContainer) return;

            const count = 80;
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 100 + Math.random() * 150;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;

                const particle = new Particle(x, y, vx, vy, {
                    lifetime: 0.5 + Math.random() * 0.7,
                    startColor: 0xffff00,  // ÎÖ∏ÎûÄÏÉâ
                    endColor: 0xff0000,    // Îπ®Í∞ÑÏÉâ
                    damping: 0.95
                });

                particleContainer.addChild(particle);
                activeParticles.push(particle);
            }
        }

        // ÎØ∏ÏÇ¨Ïùº Ï∂©Îèå ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
        function createProjectileHitParticles(x, y) {
            if (!particleContainer) return;

            const count = 5;  // 15 ‚Üí 5 (1/3)
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 100;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;

                const particle = new Particle(x, y, vx, vy, {
                    lifetime: 0.2 + Math.random() * 0.3,
                    startColor: 0xffffff,  // Ìù∞ÏÉâ
                    endColor: 0xff8800,    // Ï£ºÌô©ÏÉâ
                    damping: 0.92,
                    radius: 1  // ÏûëÏùÄ Ïä§ÌååÌÅ¨ (ÌÉ±ÌÅ¨ Ìè≠Î∞úÏùÄ 3)
                });

                particleContainer.addChild(particle);
                activeParticles.push(particle);
            }
        }

        // ÌååÌã∞ÌÅ¥ ÏóÖÎç∞Ïù¥Ìä∏
        function updateParticles(deltaTime) {
            for (let i = activeParticles.length - 1; i >= 0; i--) {
                const particle = activeParticles[i];
                const alive = particle.update(deltaTime);

                if (!alive) {
                    particleContainer.removeChild(particle);
                    particle.destroy();
                    activeParticles.splice(i, 1);
                }
            }
        }

        // ============================================
        // Collision Categories (Ï†ïÏùòÎ•º Î®ºÏ†Ä!)
        // ============================================
        // Collision categories (bit flags)
        const COLLISION_CATEGORY = {
            TANK: 0x0001,        // 0001
            PROJECTILE: 0x0002,  // 0010
            WALL: 0x0004         // 0100
        };

        // Create boundary walls
        const wallThickness = 50;
        const walls = [
            Bodies.rectangle(480, -25, 960, wallThickness, {
                isStatic: true,
                label: 'wall',
                collisionFilter: {
                    category: COLLISION_CATEGORY.WALL,
                    mask: COLLISION_CATEGORY.TANK | COLLISION_CATEGORY.PROJECTILE
                }
            }),
            Bodies.rectangle(480, 745, 960, wallThickness, {
                isStatic: true,
                label: 'wall',
                collisionFilter: {
                    category: COLLISION_CATEGORY.WALL,
                    mask: COLLISION_CATEGORY.TANK | COLLISION_CATEGORY.PROJECTILE
                }
            }),
            Bodies.rectangle(-25, 360, wallThickness, 720, {
                isStatic: true,
                label: 'wall',
                collisionFilter: {
                    category: COLLISION_CATEGORY.WALL,
                    mask: COLLISION_CATEGORY.TANK | COLLISION_CATEGORY.PROJECTILE
                }
            }),
            Bodies.rectangle(985, 360, wallThickness, 720, {
                isStatic: true,
                label: 'wall',
                collisionFilter: {
                    category: COLLISION_CATEGORY.WALL,
                    mask: COLLISION_CATEGORY.TANK | COLLISION_CATEGORY.PROJECTILE
                }
            })
        ];

        World.add(world, walls);

        // ============================================
        // Tank Class (Matter.js Wrapper)
        // ============================================
        class Tank {
            constructor(x, y, config) {
                this.config = {
                    size: config.size || 30,
                    thrustPower: config.thrustPower || 0.0003,
                    rotationSpeed: config.rotationSpeed || 3.0,
                    density: config.density || 0.08,       // Mass per area (armor thickness)
                    friction: config.friction || 0.8,
                    frictionAir: config.frictionAir || 0.12,
                    color: config.color || '#00ffff',
                    maxHealth: config.maxHealth || 100
                };

                // Define tank shape as triangle vertices (relative to center)
                const size = this.config.size * 0.8;
                const vertices = [
                    { x: size * 0.75, y: 0 },              // Front point
                    { x: -size * 0.5, y: -size * 0.4 },    // Back left
                    { x: -size * 0.5, y: size * 0.4 }      // Back right
                ];

                // Create Matter.js body from vertices - THIS IS THE TANK
                this.body = Bodies.fromVertices(x, y, [vertices], {
                    density: this.config.density,
                    friction: this.config.friction,
                    frictionAir: this.config.frictionAir,
                    frictionStatic: 1.0,
                    restitution: 0.1,
                    label: 'tank',
                    collisionFilter: {
                        category: COLLISION_CATEGORY.TANK,
                        mask: COLLISION_CATEGORY.TANK | COLLISION_CATEGORY.PROJECTILE | COLLISION_CATEGORY.WALL
                    }
                }, true);  // true = flagInternal (auto-decompose if needed)

                World.add(world, this.body);

                // Health state (no shield)
                this.health = this.config.maxHealth;
                this.alive = true;

                // Weapon state
                this.currentWeapon = 'MISSILE';  // Default weapon
                this.maxWeaponEnergy = 100;
                this.weaponEnergy = 100;
                this.weaponRechargeRate = 20; // per second

                // Score
                this.score = 0;

                // Input state
                this.thrust = 0;      // -1, 0, 1
                this.rotation = 0;    // -1, 0, 1
            }

            switchWeapon(weaponType) {
                if (WEAPON_DATA[weaponType]) {
                    this.currentWeapon = weaponType;
                    console.log(`${this.id} switched to ${WEAPON_DATA[weaponType].name}`);
                } else {
                    console.error(`Unknown weapon: ${weaponType}`);
                }
            }

            update() {
                // Don't update if destroyed
                if (!this.alive) return;

                // Apply thrust force
                if (this.thrust !== 0) {
                    const forceMagnitude = this.thrust * this.config.thrustPower;
                    const force = {
                        x: Math.cos(this.body.angle) * forceMagnitude,
                        y: Math.sin(this.body.angle) * forceMagnitude
                    };
                    Body.applyForce(this.body, this.body.position, force);
                } else {
                    // Brake when no thrust
                    const brakeFactor = 0.05;
                    Body.setVelocity(this.body, {
                        x: this.body.velocity.x * (1 - brakeFactor),
                        y: this.body.velocity.y * (1 - brakeFactor)
                    });
                }

                // Apply rotation
                if (this.rotation !== 0) {
                    const targetAngularVelocity = this.rotation * this.config.rotationSpeed;
                    Body.setAngularVelocity(this.body, targetAngularVelocity);
                } else {
                    // Stop rotation when no input
                    const rotationBrake = 0.2;
                    Body.setAngularVelocity(this.body, this.body.angularVelocity * (1 - rotationBrake));
                }

                // Recharge weapon energy (fixed 60 FPS, so 1/60 = 0.0167s per frame)
                if (this.weaponEnergy < this.maxWeaponEnergy) {
                    this.weaponEnergy = Math.min(
                        this.maxWeaponEnergy,
                        this.weaponEnergy + this.weaponRechargeRate / 60
                    );
                }

                // Reset inputs (will be set by keyboard handler)
                this.thrust = 0;
                this.rotation = 0;
            }

            takeDamage(damage) {
                if (!this.alive) return;

                // Damage health directly (no shield)
                this.health -= damage;

                // Check if destroyed
                if (this.health <= 0) {
                    this.health = 0;
                    this.destroy();
                }
            }

            destroy() {
                if (!this.alive) return;

                this.alive = false;
                console.log(`Tank ${this.id} destroyed!`);

                // Create explosion effect at tank position (Canvas)
                createExplosion(this.body.position.x, this.body.position.y);

                // Create particle explosion (PixiJS)
                createTankExplosionParticles(this.body.position.x, this.body.position.y);

                // Remove body from world
                World.remove(world, this.body);
            }

            render(ctx) {
                // Don't render if destroyed
                if (!this.alive) return;

                ctx.save();

                const pos = this.body.position;
                const angle = this.body.angle;
                const size = this.config.size * 0.8;

                // Move to tank position and rotate
                ctx.translate(pos.x, pos.y);
                ctx.rotate(angle);

                // Tank glow
                ctx.shadowColor = this.config.color;
                ctx.shadowBlur = 15;

                // Draw tank body using Matter.js vertices (for perfect match)
                // Convert world coordinates to body-local coordinates
                const vertices = this.body.vertices;
                ctx.beginPath();
                const v0 = Vector.sub(vertices[0], pos);
                const v0Rotated = Vector.rotate(v0, -angle);
                ctx.moveTo(v0Rotated.x, v0Rotated.y);

                for (let i = 1; i < vertices.length; i++) {
                    const v = Vector.sub(vertices[i], pos);
                    const vRotated = Vector.rotate(v, -angle);
                    ctx.lineTo(vRotated.x, vRotated.y);
                }
                ctx.closePath();

                ctx.fillStyle = this.config.color;
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Tank details (cylinders)
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 0.7;
                const cylSize = size * 0.15;
                const cylSpacing = size * 0.25;
                ctx.fillRect(-size * 0.4, -cylSpacing, cylSize, cylSize);
                ctx.fillRect(-size * 0.4, 0, cylSize, cylSize);
                ctx.fillRect(-size * 0.4, cylSpacing, cylSize, cylSize);
                ctx.globalAlpha = 1;

                // Weapon indicator
                ctx.strokeStyle = this.config.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(size * 0.6, 0);
                ctx.lineTo(size * 0.9, 0);
                ctx.stroke();

                ctx.restore();

                // Debug: Physics body outline (actual vertices)
                if (window.debugMode && this.body.vertices) {
                    ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const vertices = this.body.vertices;
                    ctx.moveTo(vertices[0].x, vertices[0].y);
                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(vertices[i].x, vertices[i].y);
                    }
                    ctx.closePath();
                    ctx.stroke();

                    // Draw center point
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

        }

        // ============================================
        // Projectile Class (Matter.js Wrapper)
        // ============================================
        class Projectile {
            constructor(x, y, angle, weaponData, ownerColor) {
                // Store weapon data
                this.weaponData = weaponData;
                this.type = weaponData.type;
                this.color = ownerColor || weaponData.color;  // Use tank color or weapon default

                // Calculate actual speed (DOS units ‚Üí web pixels)
                const actualSpeed = weaponData.speed * SPEED_SCALE_FACTOR;

                // LaserÎäî Î∞ÄÎèÑÎßå ÎÇÆÍ≤å (Î¨ºÎ¶¨ Î∞îÎîîÏßÄÎßå ÏßàÎüâ Í±∞Ïùò ÏóÜÏùå)
                // MissileÏùÄ ÏùºÎ∞ò Î¨ºÎ¶¨ Î∞îÎîî (Îç∞ÎØ∏ÏßÄ + Î¨ºÎ¶¨Ï†Å Ï∂©Îèå)
                const isLaser = (this.type === 'LASER');

                // Create as physical body with collision filtering
                this.body = Bodies.circle(x, y, weaponData.size, {
                    isSensor: false,   // Î™®Îëê Î¨ºÎ¶¨ Î∞îÎîî (Ï∂©Îèå Í∞êÏßÄ)
                    label: 'projectile',
                    density: isLaser ? 0.001 : 0.4,      // Î†àÏù¥Ï†ÄÎäî Î∞ÄÎèÑ ÏïÑÏ£º ÎÇÆÍ≤å (ÌÉ±ÌÅ¨Î•º Ïïà Î∞ÄÏùå)
                    frictionAir: 0,    // No air resistance for projectiles
                    restitution: 0,    // ÌäïÍπÄ ÏóÜÏùå
                    friction: 0.1,     // ÎßàÏ∞∞
                    collisionFilter: {
                        category: COLLISION_CATEGORY.PROJECTILE,
                        mask: COLLISION_CATEGORY.TANK | COLLISION_CATEGORY.WALL  // ÎØ∏ÏÇ¨ÏùºÎÅºÎ¶¨Îäî Ï∂©Îèå ÏïàÌï®
                    }
                });

                // Set initial velocity
                const velocity = {
                    x: Math.cos(angle) * actualSpeed,
                    y: Math.sin(angle) * actualSpeed
                };
                Body.setVelocity(this.body, velocity);

                World.add(world, this.body);

                this.lifetime = weaponData.lifetime;
                this.age = 0;
                this.active = true;
            }

            update(deltaTime) {
                this.age += deltaTime;

                // Remove if too old or out of bounds
                if (this.age >= this.lifetime || this.isOutOfBounds()) {
                    this.destroy();
                }
            }

            isOutOfBounds() {
                const pos = this.body.position;
                return pos.x < 0 || pos.x > 960 || pos.y < 0 || pos.y > 720;
            }

            destroy() {
                if (this.active) {
                    World.remove(world, this.body);
                    this.active = false;
                }
            }

            render(ctx) {
                if (!this.active) return;

                const pos = this.body.position;
                const vel = this.body.velocity;
                const angle = Math.atan2(vel.y, vel.x);

                ctx.save();

                // Laser: Draw as long beam
                if (this.type === 'LASER') {
                    const beamLength = 20;  // Long beam
                    const beamWidth = 2;

                    // Main beam with glow (tank color)
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 15;
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = beamWidth;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(
                        pos.x - Math.cos(angle) * beamLength / 2,
                        pos.y - Math.sin(angle) * beamLength / 2
                    );
                    ctx.lineTo(
                        pos.x + Math.cos(angle) * beamLength / 2,
                        pos.y + Math.sin(angle) * beamLength / 2
                    );
                    ctx.stroke();

                    // Inner bright core (white)
                    ctx.shadowColor = '#ffffff';
                    ctx.shadowBlur = 5;
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(
                        pos.x - Math.cos(angle) * beamLength / 2,
                        pos.y - Math.sin(angle) * beamLength / 2
                    );
                    ctx.lineTo(
                        pos.x + Math.cos(angle) * beamLength / 2,
                        pos.y + Math.sin(angle) * beamLength / 2
                    );
                    ctx.stroke();
                }
                // Missile: Draw as circle with trail
                else {
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;

                    // Draw projectile
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, this.weaponData.size, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw trail
                    const speed = Math.sqrt(vel.x ** 2 + vel.y ** 2);
                    const trailLength = Math.min(speed * 0.3, 15);

                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    ctx.lineTo(
                        pos.x - Math.cos(angle) * trailLength,
                        pos.y - Math.sin(angle) * trailLength
                    );
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        // ============================================
        // Game Constants
        // ============================================
        // Speed scale factor: DOS game units ‚Üí Web canvas pixels
        // DOS game had smaller resolution (320x200 or 640x480)
        // Web canvas is 960x720, so we need to scale down
        // Original MISSILE speed: 200 (DOS units) ‚Üí 2 px/s (web)
        const SPEED_SCALE_FACTOR = 0.01;  // 200 * 0.01 = 2

        // Weapon Data (from original game, speeds in DOS units)
        const WEAPON_DATA = {
            MISSILE: {
                name: 'MISSILE',
                type: 'MISSILE',
                damage: 4,
                energyCost: 4,
                speed: 200,        // DOS units
                price: 2,
                color: '#ffff00',
                lifetime: 3.0,
                size: 2
            },
            LASER: {
                name: 'BEAM LASER',
                type: 'LASER',
                damage: 6,
                energyCost: 6,
                speed: 400,        // DOS units (2x faster than missile)
                price: 150,
                color: '#ff0000',
                lifetime: 2.0,
                size: 1.5
            },
            DOUBLE_MISSILE: {
                name: 'DOUBLE MISSILE',
                type: 'DOUBLE_MISSILE',
                damage: 6,
                energyCost: 4,
                speed: 200,        // DOS units
                price: 100,
                color: '#ffff00',
                lifetime: 3.0,
                size: 2,
                projectileCount: 2
            }
        };

        // ============================================
        // Game State
        // ============================================
        const playerTank = new Tank(480, 360, {
            size: 30,
            thrustPower: 0.01,
            rotationSpeed: 0.01,
            color: '#00ffff'
        });
        playerTank.id = 'TANK 1';

        const enemyTank = new Tank(240, 180, {
            size: 30,
            thrustPower: 0.01,
            rotationSpeed: 0.01,
            color: '#ff00ff'
        });
        enemyTank.id = 'TANK 2';

        // Tank array for UI updates (max 6 tanks)
        const tanks = [playerTank, enemyTank, null, null, null, null];

        const projectiles = [];
        const keys = {};

        // ============================================
        // UI Update Function
        // ============================================
        function updateUI() {
            tanks.forEach((tank, index) => {
                const statPanel = document.getElementById(`tank${index + 1}-stat`);
                if (!statPanel) return;

                if (tank && tank.alive) {
                    // Update tank name
                    const nameEl = statPanel.querySelector('.tank-name');
                    nameEl.textContent = tank.id;
                    nameEl.style.color = tank.config.color;

                    // Update health gauge
                    const healthPercent = (tank.health / tank.config.maxHealth) * 100;
                    const healthFill = statPanel.querySelector('.gauge-fill.health');
                    healthFill.style.height = `${healthPercent}%`;

                    // Update weapon energy gauge
                    const energyPercent = (tank.weaponEnergy / tank.maxWeaponEnergy) * 100;
                    const weaponFill = statPanel.querySelector('.gauge-fill.weapon');
                    weaponFill.style.height = `${energyPercent}%`;

                    // Update weapon info
                    const weaponInfo = statPanel.querySelector('.weapon-info');
                    weaponInfo.textContent = WEAPON_DATA[tank.currentWeapon]?.name.substring(0, 6) || 'N/A';

                    // Update score
                    const scoreEl = statPanel.querySelector('.score');
                    scoreEl.textContent = `$${tank.score}`;
                } else {
                    // Empty slot or dead tank
                    const nameEl = statPanel.querySelector('.tank-name');
                    nameEl.textContent = `-`;
                    nameEl.style.color = '#444444';

                    const healthFill = statPanel.querySelector('.gauge-fill.health');
                    healthFill.style.height = '0%';

                    const weaponFill = statPanel.querySelector('.gauge-fill.weapon');
                    weaponFill.style.height = '0%';

                    const weaponInfo = statPanel.querySelector('.weapon-info');
                    weaponInfo.textContent = '-';

                    const scoreEl = statPanel.querySelector('.score');
                    scoreEl.textContent = '-';
                }
            });
        }

        // ============================================
        // Input Handler
        // ============================================
        window.addEventListener('keydown', (e) => {
            // Prevent arrow key scrolling and space bar scrolling
            if (e.code.startsWith('Arrow') || e.code === 'Space') {
                e.preventDefault();
            }
            keys[e.code] = true;
        });

        window.addEventListener('keyup', (e) => {
            // Prevent arrow key scrolling and space bar scrolling
            if (e.code.startsWith('Arrow') || e.code === 'Space') {
                e.preventDefault();
            }
            keys[e.code] = false;

            // Reset fire flag for Space
            if (e.code === 'Space') {
                keys['Space_fired'] = false;
            }
        });

        function handleInput() {
            // Player Tank Controls
            // Thrust
            if (keys['ArrowUp']) {
                playerTank.thrust = 1;
            } else if (keys['ArrowDown']) {
                playerTank.thrust = -1;
            }

            // Rotation (car-like steering)
            const steeringDirection = playerTank.thrust >= 0 ? 1 : -1;

            if (keys['ArrowLeft']) {
                playerTank.rotation = -1 * steeringDirection;
            } else if (keys['ArrowRight']) {
                playerTank.rotation = 1 * steeringDirection;
            }

            // Fire projectile (Space key)
            if (keys['Space'] && !keys['Space_fired']) {
                fireProjectile(playerTank);
                keys['Space_fired'] = true;
            }

            // Weapon switching (1, 2, 3 keys)
            if (keys['Digit1']) {
                playerTank.switchWeapon('MISSILE');
                keys['Digit1'] = false;
            }
            if (keys['Digit2']) {
                playerTank.switchWeapon('LASER');
                keys['Digit2'] = false;
            }
            if (keys['Digit3']) {
                playerTank.switchWeapon('DOUBLE_MISSILE');
                keys['Digit3'] = false;
            }

            // Debug toggle
            if (keys['KeyD']) {
                window.debugMode = !window.debugMode;
                keys['KeyD'] = false;
            }
        }

        function fireProjectile(tank) {
            // Can't fire if destroyed
            if (!tank.alive) return;

            // Get weapon data from tank's current weapon
            const weaponData = WEAPON_DATA[tank.currentWeapon];
            if (!weaponData) {
                console.error(`Unknown weapon type: ${tank.currentWeapon}`);
                return;
            }

            // Check if enough energy
            if (tank.weaponEnergy < weaponData.energyCost) {
                return; // Not enough energy
            }

            // Consume weapon energy
            tank.weaponEnergy -= weaponData.energyCost;

            const size = tank.config.size * 0.8;
            // ÏÇºÍ∞ÅÌòï Ïïû ÎÅùÏóêÏÑú ÏÉùÏÑ± (size * 0.75Í∞Ä ÏÇºÍ∞ÅÌòï Ïïû ÎÅù ÏúÑÏπò)
            const barrelLength = size * 0.75 + 5;  // Ïïû ÎÅùÏóêÏÑú 5px Îçî Ïïû

            // Multi-projectile weapons (DOUBLE_MISSILE, etc.)
            const projectileCount = weaponData.projectileCount || 1;

            if (projectileCount === 1) {
                // Single projectile (MISSILE, LASER)
                const spawnX = tank.body.position.x + Math.cos(tank.body.angle) * barrelLength;
                const spawnY = tank.body.position.y + Math.sin(tank.body.angle) * barrelLength;

                const projectile = new Projectile(
                    spawnX,
                    spawnY,
                    tank.body.angle,
                    weaponData,
                    tank.config.color
                );
                projectiles.push(projectile);
            } else {
                // Multiple projectiles (DOUBLE_MISSILE: 2Í∞úÎ•º Ï¢åÏö∞Î°ú)
                const spacing = 6;  // ÎØ∏ÏÇ¨Ïùº Í∞Ñ Í∞ÑÍ≤©
                const perpAngle = tank.body.angle + Math.PI / 2;  // ÌÉ±ÌÅ¨Ïóê ÏàòÏßÅ Î∞©Ìñ•

                for (let i = 0; i < projectileCount; i++) {
                    // Ï§ëÏã¨ÏóêÏÑú Ï¢åÏö∞Î°ú Î∞∞Ïπò
                    const offset = (i - (projectileCount - 1) / 2) * spacing;

                    const spawnX = tank.body.position.x +
                                   Math.cos(tank.body.angle) * barrelLength +
                                   Math.cos(perpAngle) * offset;
                    const spawnY = tank.body.position.y +
                                   Math.sin(tank.body.angle) * barrelLength +
                                   Math.sin(perpAngle) * offset;

                    const projectile = new Projectile(
                        spawnX,
                        spawnY,
                        tank.body.angle,
                        weaponData,
                        tank.config.color
                    );
                    projectiles.push(projectile);
                }
            }
        }

        // ============================================
        // Collision Handler
        // ============================================
        Matter.Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach(pair => {
                const { bodyA, bodyB } = pair;

                // Check projectile ‚Üí tank collision
                if (bodyA.label === 'projectile' && bodyB.label === 'tank') {
                    handleProjectileHit(bodyA, bodyB);
                } else if (bodyA.label === 'tank' && bodyB.label === 'projectile') {
                    handleProjectileHit(bodyB, bodyA);
                }
                // Check projectile ‚Üí wall collision
                else if (bodyA.label === 'projectile' && bodyB.label === 'wall') {
                    handleProjectileWallHit(bodyA);
                } else if (bodyA.label === 'wall' && bodyB.label === 'projectile') {
                    handleProjectileWallHit(bodyB);
                }
                // TODO: Projectile ‚Üí projectile collision
                // Will be implemented with weapon system (different weapon types have different collision rules)
                // e.g., missile vs missile = explode, missile vs laser = pass through
            });
        });

        function handleProjectileHit(projectileBody, tankBody) {
            // Find projectile object
            const projectile = projectiles.find(p => p.body === projectileBody);
            if (!projectile || !projectile.active) return;

            // Find which tank was hit
            let hitTank = null;
            if (tankBody === playerTank.body) {
                hitTank = playerTank;
            } else if (tankBody === enemyTank.body) {
                hitTank = enemyTank;
            }

            if (!hitTank || !hitTank.alive) return;

            // Apply damage
            hitTank.takeDamage(projectile.weaponData.damage);

            // Create visual feedback (Canvas)
            createHitEffect(projectileBody.position.x, projectileBody.position.y);

            // Create particle effect (PixiJS)
            createProjectileHitParticles(projectileBody.position.x, projectileBody.position.y);

            // Remove projectile
            projectile.destroy();

            console.log('Hit! Damage:', projectile.weaponData.damage,
                'Weapon:', projectile.weaponData.name,
                'Tank:', hitTank.id,
                'Shield:', Math.round(hitTank.shield),
                'Health:', Math.round(hitTank.health));
        }

        function handleProjectileWallHit(projectileBody) {
            // Find projectile object
            const projectile = projectiles.find(p => p.body === projectileBody);
            if (!projectile || !projectile.active) return;

            // Create small visual feedback (Canvas)
            createHitEffect(projectileBody.position.x, projectileBody.position.y);

            // Create particle effect (PixiJS)
            createProjectileHitParticles(projectileBody.position.x, projectileBody.position.y);

            // Remove projectile
            projectile.destroy();

            console.log('Projectile hit wall');
        }

        // Hit effects array
        const hitEffects = [];
        const explosions = [];

        function createHitEffect(x, y) {
            hitEffects.push({
                x: x,
                y: y,
                age: 0,
                maxAge: 0.15  // 0.5 ‚Üí 0.15 (30%)
            });
        }

        function createExplosion(x, y) {
            // Create multiple explosion rings
            for (let i = 0; i < 3; i++) {
                explosions.push({
                    x: x,
                    y: y,
                    age: 0,
                    maxAge: 0.6 + i * 0.1,
                    delay: i * 0.05,
                    size: 1 + i * 0.3
                });
            }
        }

        function updateHitEffects(deltaTime) {
            for (let i = hitEffects.length - 1; i >= 0; i--) {
                hitEffects[i].age += deltaTime;
                if (hitEffects[i].age >= hitEffects[i].maxAge) {
                    hitEffects.splice(i, 1);
                }
            }
        }

        function updateExplosions(deltaTime) {
            for (let i = explosions.length - 1; i >= 0; i--) {
                explosions[i].age += deltaTime;
                if (explosions[i].age >= explosions[i].maxAge) {
                    explosions.splice(i, 1);
                }
            }
        }

        function renderHitEffects(ctx) {
            for (const effect of hitEffects) {
                const progress = effect.age / effect.maxAge;
                const alpha = 1 - progress;
                const radius = 3 + progress * 9;  // 10 + 30 ‚Üí 3 + 9 (30%)

                ctx.save();

                // Outer ring
                ctx.strokeStyle = `rgba(255, 255, 0, ${alpha * 0.8})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                // Inner flash
                ctx.fillStyle = `rgba(255, 200, 0, ${alpha * 0.5})`;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, radius * 0.5, 0, Math.PI * 2);
                ctx.fill();

                // Glow
                ctx.shadowColor = 'rgba(255, 255, 0, 1)';
                ctx.shadowBlur = 20;
                ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        function renderExplosions(ctx) {
            for (const explosion of explosions) {
                // Skip if still delayed
                if (explosion.age < explosion.delay) continue;

                const adjustedAge = explosion.age - explosion.delay;
                const progress = adjustedAge / explosion.maxAge;
                const alpha = 1 - progress;
                const radius = 5 + progress * 50 * explosion.size;

                ctx.save();

                // Outer ring (orange to red)
                const red = 255;
                const green = Math.floor(200 * (1 - progress));
                ctx.strokeStyle = `rgba(${red}, ${green}, 0, ${alpha * 0.8})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                // Inner ring
                ctx.strokeStyle = `rgba(255, 255, 0, ${alpha * 0.6})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, radius * 0.7, 0, Math.PI * 2);
                ctx.stroke();

                // Flash at center (early in explosion)
                if (progress < 0.3) {
                    const flashAlpha = (1 - progress / 0.3) * 0.8;
                    ctx.shadowColor = 'rgba(255, 200, 0, 1)';
                    ctx.shadowBlur = 30;
                    ctx.fillStyle = `rgba(255, 200, 0, ${flashAlpha})`;
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        // ============================================
        // AI System
        // ============================================
        let aiFireCooldown = 0;
        const AI_FIRE_COOLDOWN = 1.5;  // seconds

        function updateAI(deltaTime) {
            // Simple AI: Track player and fire
            const enemy = enemyTank;
            const target = playerTank;

            // Don't do anything if enemy is destroyed or target is destroyed
            if (!enemy.alive || !target.alive) return;

            // Calculate vector to target
            const dx = target.body.position.x - enemy.body.position.x;
            const dy = target.body.position.y - enemy.body.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angleToTarget = Math.atan2(dy, dx);

            // Calculate angle difference
            let angleDiff = angleToTarget - enemy.body.angle;

            // Normalize angle difference to [-œÄ, œÄ]
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

            // Rotate towards target
            if (Math.abs(angleDiff) > 0.1) {
                enemy.rotation = angleDiff > 0 ? 1 : -1;
            } else {
                enemy.rotation = 0;
            }

            // Move towards target if too far
            if (distance > 200) {
                enemy.thrust = 1;
            } else if (distance < 150) {
                enemy.thrust = -1;
            } else {
                enemy.thrust = 0;
            }

            // Fire at target if aimed correctly
            aiFireCooldown -= deltaTime;
            if (Math.abs(angleDiff) < 0.2 && aiFireCooldown <= 0) {
                fireProjectile(enemy);
                aiFireCooldown = AI_FIRE_COOLDOWN;
            }
        }

        // ============================================
        // Renderer
        // ============================================
        function render() {
            // Clear canvas
            ctx.fillStyle = '#000011';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw starfield background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            for (let i = 0; i < 100; i++) {
                const x = (i * 113) % canvas.width;
                const y = (i * 197) % canvas.height;
                ctx.fillRect(x, y, 1, 1);
            }

            // Draw grid
            ctx.strokeStyle = 'rgba(0, 100, 150, 0.2)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw walls (visual)
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 3;
            ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);

            // Draw tanks
            playerTank.render(ctx);
            enemyTank.render(ctx);

            // Draw projectiles
            for (const projectile of projectiles) {
                if (projectile.active) {
                    projectile.render(ctx);
                }
            }

            // Draw hit effects
            renderHitEffects(ctx);

            // Draw explosions
            renderExplosions(ctx);
        }

        // ============================================
        // Game Loop
        // ============================================
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 60;
        let lastFpsUpdate = performance.now();

        function gameLoop(currentTime) {
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // FPS calculation
            frameCount++;
            if (currentTime - lastFpsUpdate >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }

            // Handle input
            handleInput();

            // Update AI
            updateAI(deltaTime);

            // Update tanks
            playerTank.update();
            enemyTank.update();

            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                projectiles[i].update(deltaTime);
                if (!projectiles[i].active) {
                    projectiles.splice(i, 1);
                }
            }

            // Update hit effects
            updateHitEffects(deltaTime);

            // Update explosions
            updateExplosions(deltaTime);

            // Update particles (PixiJS)
            updateParticles(deltaTime);

            // Update Matter.js physics
            Engine.update(engine, 1000 / 60);  // Fixed 60 FPS timestep

            // Render
            render();

            // Update UI gauges
            updateUI();

            requestAnimationFrame(gameLoop);
        }

        // Start game loop
        console.log('üöÄ Matter.js Prototype Starting...');

        // Initialize PixiJS
        initPixiJS();

        requestAnimationFrame(gameLoop);

        // Debug mode
        window.debugMode = false;
    </script>
</body>
</html>
