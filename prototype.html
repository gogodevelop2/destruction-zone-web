<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Destruction Zone - Matter.js Prototype</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000011;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #00ffff;
        }

        h1 {
            margin: 20px 0;
            font-size: 24px;
            text-shadow: 0 0 10px #00ffff;
        }

        #gameCanvas {
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            background: #000011;
        }

        .info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 100, 150, 0.2);
            border: 1px solid #00ffff;
            border-radius: 5px;
            max-width: 960px;
        }

        .info h2 {
            margin-bottom: 10px;
            font-size: 18px;
        }

        .info p {
            margin: 5px 0;
            font-size: 14px;
            color: #00dddd;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .key {
            background: rgba(0, 255, 255, 0.1);
            padding: 5px;
            border-radius: 3px;
        }

        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border: 1px solid #00ffff;
            font-size: 12px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <h1>üéÆ DESTRUCTION ZONE - Matter.js Prototype</h1>

    <canvas id="gameCanvas" width="960" height="720"></canvas>

    <div class="info">
        <h2>Controls</h2>
        <div class="controls">
            <p class="key">‚¨ÜÔ∏è Arrow Up - Thrust Forward</p>
            <p class="key">‚¨áÔ∏è Arrow Down - Thrust Backward</p>
            <p class="key">‚¨ÖÔ∏è Arrow Left - Rotate Left</p>
            <p class="key">‚û°Ô∏è Arrow Right - Rotate Right</p>
            <p class="key">SPACE - Fire Projectile</p>
            <p class="key">D - Toggle Debug Mode</p>
        </div>
        <p style="margin-top: 10px;">üéØ Goal: Test projectiles, collision detection, and multiple tanks</p>
    </div>

    <div id="stats"></div>

    <!-- Matter.js Library -->
    <script src="js/lib/matter.min.js"></script>

    <!-- Prototype Script -->
    <script>
        // ============================================
        // Matter.js Prototype - Single Tank Test
        // ============================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statsDiv = document.getElementById('stats');

        // Create Matter.js engine
        const Engine = Matter.Engine;
        const World = Matter.World;
        const Bodies = Matter.Bodies;
        const Body = Matter.Body;
        const Vector = Matter.Vector;

        const engine = Engine.create({
            gravity: { x: 0, y: 0 }  // Top-down, no gravity
        });

        const world = engine.world;

        // Create boundary walls
        const wallThickness = 50;
        const walls = [
            Bodies.rectangle(480, -25, 960, wallThickness, { isStatic: true, label: 'wall' }),
            Bodies.rectangle(480, 745, 960, wallThickness, { isStatic: true, label: 'wall' }),
            Bodies.rectangle(-25, 360, wallThickness, 720, { isStatic: true, label: 'wall' }),
            Bodies.rectangle(985, 360, wallThickness, 720, { isStatic: true, label: 'wall' })
        ];

        World.add(world, walls);

        // ============================================
        // Tank Class (Matter.js Wrapper)
        // ============================================
        class Tank {
            constructor(x, y, config) {
                this.config = {
                    size: config.size || 30,
                    thrustPower: config.thrustPower || 0.0003,
                    rotationSpeed: config.rotationSpeed || 3.0,
                    density: config.density || 0.08,       // Mass per area (armor thickness)
                    friction: config.friction || 0.8,
                    frictionAir: config.frictionAir || 0.12,
                    color: config.color || '#00ffff'
                };

                // Define tank shape as triangle vertices (relative to center)
                const size = this.config.size * 0.8;
                const vertices = [
                    { x: size * 0.75, y: 0 },              // Front point
                    { x: -size * 0.5, y: -size * 0.4 },    // Back left
                    { x: -size * 0.5, y: size * 0.4 }      // Back right
                ];

                // Create Matter.js body from vertices - THIS IS THE TANK
                this.body = Bodies.fromVertices(x, y, [vertices], {
                    density: this.config.density,
                    friction: this.config.friction,
                    frictionAir: this.config.frictionAir,
                    frictionStatic: 1.0,
                    restitution: 0.1,
                    label: 'tank'
                }, true);  // true = flagInternal (auto-decompose if needed)

                World.add(world, this.body);

                // Input state
                this.thrust = 0;      // -1, 0, 1
                this.rotation = 0;    // -1, 0, 1
            }

            update() {
                // Apply thrust force
                if (this.thrust !== 0) {
                    const forceMagnitude = this.thrust * this.config.thrustPower;
                    const force = {
                        x: Math.cos(this.body.angle) * forceMagnitude,
                        y: Math.sin(this.body.angle) * forceMagnitude
                    };
                    Body.applyForce(this.body, this.body.position, force);
                } else {
                    // Brake when no thrust
                    const brakeFactor = 0.05;
                    Body.setVelocity(this.body, {
                        x: this.body.velocity.x * (1 - brakeFactor),
                        y: this.body.velocity.y * (1 - brakeFactor)
                    });
                }

                // Apply rotation
                if (this.rotation !== 0) {
                    const targetAngularVelocity = this.rotation * this.config.rotationSpeed;
                    Body.setAngularVelocity(this.body, targetAngularVelocity);
                } else {
                    // Stop rotation when no input
                    const rotationBrake = 0.2;
                    Body.setAngularVelocity(this.body, this.body.angularVelocity * (1 - rotationBrake));
                }

                // Reset inputs (will be set by keyboard handler)
                this.thrust = 0;
                this.rotation = 0;
            }

            render(ctx) {
                ctx.save();

                const pos = this.body.position;
                const angle = this.body.angle;
                const size = this.config.size * 0.8;

                // Move to tank position and rotate
                ctx.translate(pos.x, pos.y);
                ctx.rotate(angle);

                // Tank glow
                ctx.shadowColor = this.config.color;
                ctx.shadowBlur = 15;

                // Draw tank body using Matter.js vertices (for perfect match)
                // Convert world coordinates to body-local coordinates
                const vertices = this.body.vertices;
                ctx.beginPath();
                const v0 = Vector.sub(vertices[0], pos);
                const v0Rotated = Vector.rotate(v0, -angle);
                ctx.moveTo(v0Rotated.x, v0Rotated.y);

                for (let i = 1; i < vertices.length; i++) {
                    const v = Vector.sub(vertices[i], pos);
                    const vRotated = Vector.rotate(v, -angle);
                    ctx.lineTo(vRotated.x, vRotated.y);
                }
                ctx.closePath();

                ctx.fillStyle = this.config.color;
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Tank details (cylinders)
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 0.7;
                const cylSize = size * 0.15;
                const cylSpacing = size * 0.25;
                ctx.fillRect(-size * 0.4, -cylSpacing, cylSize, cylSize);
                ctx.fillRect(-size * 0.4, 0, cylSize, cylSize);
                ctx.fillRect(-size * 0.4, cylSpacing, cylSize, cylSize);
                ctx.globalAlpha = 1;

                // Weapon indicator
                ctx.strokeStyle = this.config.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(size * 0.6, 0);
                ctx.lineTo(size * 0.9, 0);
                ctx.stroke();

                ctx.restore();

                // Debug: Physics body outline (actual vertices)
                if (window.debugMode && this.body.vertices) {
                    ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const vertices = this.body.vertices;
                    ctx.moveTo(vertices[0].x, vertices[0].y);
                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(vertices[i].x, vertices[i].y);
                    }
                    ctx.closePath();
                    ctx.stroke();

                    // Draw center point
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // ============================================
        // Projectile Class (Matter.js Wrapper)
        // ============================================
        class Projectile {
            constructor(x, y, angle, speed, config) {
                this.config = {
                    damage: config.damage || 10,
                    color: config.color || '#ffff00',
                    size: config.size || 3
                };

                // Create as physical body with high density
                this.body = Bodies.circle(x, y, this.config.size, {
                    isSensor: false,  // Î¨ºÎ¶¨Ï†Å Ï∂©Îèå ÌôúÏÑ±Ìôî
                    label: 'projectile',
                    density: 0.4,  // ÌÉ±ÌÅ¨Ïùò 5Î∞∞ (ÌÉ±ÌÅ¨: 0.08)
                    frictionAir: 0,  // No air resistance for projectiles
                    restitution: 0,  // ÌäïÍπÄ ÏóÜÏùå (0.8 ‚Üí 0)
                    friction: 0.1  // ÎßàÏ∞∞
                });

                // Set initial velocity
                const velocity = {
                    x: Math.cos(angle) * speed,
                    y: Math.sin(angle) * speed
                };
                Body.setVelocity(this.body, velocity);

                World.add(world, this.body);

                this.lifetime = 3.0;  // seconds
                this.age = 0;
                this.active = true;
            }

            update(deltaTime) {
                this.age += deltaTime;

                // Remove if too old or out of bounds
                if (this.age >= this.lifetime || this.isOutOfBounds()) {
                    this.destroy();
                }
            }

            isOutOfBounds() {
                const pos = this.body.position;
                return pos.x < 0 || pos.x > 960 || pos.y < 0 || pos.y > 720;
            }

            destroy() {
                if (this.active) {
                    World.remove(world, this.body);
                    this.active = false;
                }
            }

            render(ctx) {
                if (!this.active) return;

                const pos = this.body.position;

                ctx.save();
                ctx.shadowColor = this.config.color;
                ctx.shadowBlur = 10;

                // Draw projectile
                ctx.fillStyle = this.config.color;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, this.config.size, 0, Math.PI * 2);
                ctx.fill();

                // Draw trail
                const vel = this.body.velocity;
                const speed = Math.sqrt(vel.x ** 2 + vel.y ** 2);
                const trailLength = Math.min(speed * 0.3, 15);
                const angle = Math.atan2(vel.y, vel.x);

                ctx.strokeStyle = this.config.color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(
                    pos.x - Math.cos(angle) * trailLength,
                    pos.y - Math.sin(angle) * trailLength
                );
                ctx.stroke();

                ctx.restore();
            }
        }

        // ============================================
        // Game State
        // ============================================
        const playerTank = new Tank(480, 360, {
            size: 30,
            thrustPower: 0.01,
            rotationSpeed: 0.01,
            color: '#00ffff'
        });
        playerTank.id = 'player';

        const enemyTank = new Tank(240, 180, {
            size: 30,
            thrustPower: 0.01,
            rotationSpeed: 0.01,
            color: '#ff00ff'
        });
        enemyTank.id = 'enemy';

        const projectiles = [];
        const keys = {};

        // ============================================
        // Input Handler
        // ============================================
        window.addEventListener('keydown', (e) => {
            // Prevent arrow key scrolling and space bar scrolling
            if (e.code.startsWith('Arrow') || e.code === 'Space') {
                e.preventDefault();
            }
            keys[e.code] = true;
        });

        window.addEventListener('keyup', (e) => {
            // Prevent arrow key scrolling and space bar scrolling
            if (e.code.startsWith('Arrow') || e.code === 'Space') {
                e.preventDefault();
            }
            keys[e.code] = false;

            // Reset fire flag for Space
            if (e.code === 'Space') {
                keys['Space_fired'] = false;
            }
        });

        function handleInput() {
            // Player Tank Controls
            // Thrust
            if (keys['ArrowUp']) {
                playerTank.thrust = 1;
            } else if (keys['ArrowDown']) {
                playerTank.thrust = -1;
            }

            // Rotation (car-like steering)
            const steeringDirection = playerTank.thrust >= 0 ? 1 : -1;

            if (keys['ArrowLeft']) {
                playerTank.rotation = -1 * steeringDirection;
            } else if (keys['ArrowRight']) {
                playerTank.rotation = 1 * steeringDirection;
            }

            // Fire projectile (Space key)
            if (keys['Space'] && !keys['Space_fired']) {
                fireProjectile(playerTank, '#00ffff');
                keys['Space_fired'] = true;
            }

            // Debug toggle
            if (keys['KeyD']) {
                window.debugMode = !window.debugMode;
                keys['KeyD'] = false;
            }
        }

        function fireProjectile(tank, color) {
            const size = tank.config.size * 0.8;
            // ÏÇºÍ∞ÅÌòï Ïïû ÎÅùÏóêÏÑú ÏÉùÏÑ± (size * 0.75Í∞Ä ÏÇºÍ∞ÅÌòï Ïïû ÎÅù ÏúÑÏπò)
            const barrelLength = size * 0.75 + 5;  // Ïïû ÎÅùÏóêÏÑú 5px Îçî Ïïû

            // Calculate spawn position at barrel tip
            const spawnX = tank.body.position.x + Math.cos(tank.body.angle) * barrelLength;
            const spawnY = tank.body.position.y + Math.sin(tank.body.angle) * barrelLength;

            const projectile = new Projectile(
                spawnX,
                spawnY,
                tank.body.angle,
                3,  // speed
                {
                    damage: 10,
                    color: color,
                    size: 2  // ÌÅ¨Í∏∞ Ï∂ïÏÜå (6 ‚Üí 2)
                }
            );

            projectiles.push(projectile);
        }

        // ============================================
        // Collision Handler
        // ============================================
        Matter.Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach(pair => {
                const { bodyA, bodyB } = pair;

                // Check projectile ‚Üí tank collision
                if (bodyA.label === 'projectile' && bodyB.label === 'tank') {
                    handleProjectileHit(bodyA, bodyB);
                } else if (bodyA.label === 'tank' && bodyB.label === 'projectile') {
                    handleProjectileHit(bodyB, bodyA);
                }
                // Check projectile ‚Üí wall collision
                else if (bodyA.label === 'projectile' && bodyB.label === 'wall') {
                    handleProjectileWallHit(bodyA);
                } else if (bodyA.label === 'wall' && bodyB.label === 'projectile') {
                    handleProjectileWallHit(bodyB);
                }
            });
        });

        function handleProjectileHit(projectileBody, tankBody) {
            // Find projectile object
            const projectile = projectiles.find(p => p.body === projectileBody);
            if (!projectile || !projectile.active) return;

            // Find which tank was hit
            let hitTank = null;
            if (tankBody === playerTank.body) {
                hitTank = playerTank;
            } else if (tankBody === enemyTank.body) {
                hitTank = enemyTank;
            }

            // Create visual feedback
            createHitEffect(projectileBody.position.x, projectileBody.position.y);

            // Remove projectile
            projectile.destroy();

            console.log('Hit! Damage:', projectile.config.damage, 'Tank:', hitTank ? hitTank.id : 'unknown');
        }

        function handleProjectileWallHit(projectileBody) {
            // Find projectile object
            const projectile = projectiles.find(p => p.body === projectileBody);
            if (!projectile || !projectile.active) return;

            // Create small visual feedback
            createHitEffect(projectileBody.position.x, projectileBody.position.y);

            // Remove projectile
            projectile.destroy();

            console.log('Projectile hit wall');
        }

        // Hit effects array
        const hitEffects = [];

        function createHitEffect(x, y) {
            hitEffects.push({
                x: x,
                y: y,
                age: 0,
                maxAge: 0.15  // 0.5 ‚Üí 0.15 (30%)
            });
        }

        function updateHitEffects(deltaTime) {
            for (let i = hitEffects.length - 1; i >= 0; i--) {
                hitEffects[i].age += deltaTime;
                if (hitEffects[i].age >= hitEffects[i].maxAge) {
                    hitEffects.splice(i, 1);
                }
            }
        }

        function renderHitEffects(ctx) {
            for (const effect of hitEffects) {
                const progress = effect.age / effect.maxAge;
                const alpha = 1 - progress;
                const radius = 3 + progress * 9;  // 10 + 30 ‚Üí 3 + 9 (30%)

                ctx.save();

                // Outer ring
                ctx.strokeStyle = `rgba(255, 255, 0, ${alpha * 0.8})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                // Inner flash
                ctx.fillStyle = `rgba(255, 200, 0, ${alpha * 0.5})`;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, radius * 0.5, 0, Math.PI * 2);
                ctx.fill();

                // Glow
                ctx.shadowColor = 'rgba(255, 255, 0, 1)';
                ctx.shadowBlur = 20;
                ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // ============================================
        // AI System
        // ============================================
        let aiFireCooldown = 0;
        const AI_FIRE_COOLDOWN = 1.5;  // seconds

        function updateAI(deltaTime) {
            // Simple AI: Track player and fire
            const enemy = enemyTank;
            const target = playerTank;

            // Calculate vector to target
            const dx = target.body.position.x - enemy.body.position.x;
            const dy = target.body.position.y - enemy.body.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angleToTarget = Math.atan2(dy, dx);

            // Calculate angle difference
            let angleDiff = angleToTarget - enemy.body.angle;

            // Normalize angle difference to [-œÄ, œÄ]
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

            // Rotate towards target
            if (Math.abs(angleDiff) > 0.1) {
                enemy.rotation = angleDiff > 0 ? 1 : -1;
            } else {
                enemy.rotation = 0;
            }

            // Move towards target if too far
            if (distance > 200) {
                enemy.thrust = 1;
            } else if (distance < 150) {
                enemy.thrust = -1;
            } else {
                enemy.thrust = 0;
            }

            // Fire at target if aimed correctly
            aiFireCooldown -= deltaTime;
            if (Math.abs(angleDiff) < 0.2 && aiFireCooldown <= 0) {
                fireProjectile(enemy, '#ff00ff');
                aiFireCooldown = AI_FIRE_COOLDOWN;
            }
        }

        // ============================================
        // Renderer
        // ============================================
        function render() {
            // Clear canvas
            ctx.fillStyle = '#000011';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw starfield background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            for (let i = 0; i < 100; i++) {
                const x = (i * 113) % canvas.width;
                const y = (i * 197) % canvas.height;
                ctx.fillRect(x, y, 1, 1);
            }

            // Draw grid
            ctx.strokeStyle = 'rgba(0, 100, 150, 0.2)';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw walls (visual)
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 3;
            ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);

            // Draw tanks
            playerTank.render(ctx);
            enemyTank.render(ctx);

            // Draw projectiles
            for (const projectile of projectiles) {
                if (projectile.active) {
                    projectile.render(ctx);
                }
            }

            // Draw hit effects
            renderHitEffects(ctx);
        }

        // ============================================
        // Game Loop
        // ============================================
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 60;
        let lastFpsUpdate = performance.now();

        function gameLoop(currentTime) {
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // FPS calculation
            frameCount++;
            if (currentTime - lastFpsUpdate >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }

            // Handle input
            handleInput();

            // Update AI
            updateAI(deltaTime);

            // Update tanks
            playerTank.update();
            enemyTank.update();

            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                projectiles[i].update(deltaTime);
                if (!projectiles[i].active) {
                    projectiles.splice(i, 1);
                }
            }

            // Update hit effects
            updateHitEffects(deltaTime);

            // Update Matter.js physics
            Engine.update(engine, 1000 / 60);  // Fixed 60 FPS timestep

            // Render
            render();

            // Update stats
            const speed = Math.sqrt(
                playerTank.body.velocity.x ** 2 +
                playerTank.body.velocity.y ** 2
            );
            statsDiv.innerHTML = `
                <strong>PLAYER</strong><br>
                FPS: ${fps}<br>
                Pos: (${Math.round(playerTank.body.position.x)}, ${Math.round(playerTank.body.position.y)})<br>
                Angle: ${(playerTank.body.angle * 180 / Math.PI).toFixed(1)}¬∞<br>
                Speed: ${speed.toFixed(1)} px/s<br>
                <br>
                <strong>GAME</strong><br>
                Projectiles: ${projectiles.length}<br>
                Bodies: ${world.bodies.length}<br>
                <br>
                <span style="color: #888;">Space - Fire</span><br>
                <span style="color: #888;">D - Debug</span>
            `;

            requestAnimationFrame(gameLoop);
        }

        // Start game loop
        console.log('üöÄ Matter.js Prototype Starting...');
        requestAnimationFrame(gameLoop);

        // Debug mode
        window.debugMode = false;
    </script>
</body>
</html>
